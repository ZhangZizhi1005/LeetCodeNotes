## 方法一：线性搜索（TimeOut） ##

> **思路**

将每个元素和它之前的k个元素中比较查看他们是否相等

> **算法**

维护一个k大小的滑动窗口，在这个窗口中搜索是否存在跟当前相等的元素

> **代码**

见：linear_search

> **复杂度分析**

- 时间复杂度分析：O(n*min*(n,k))
  - 哪怕k比n大，一次搜索也需要比较n次
  - 每次搜索时候都需要检查一个为长度为k的窗口
    
- 空间复杂度：O(1)

---
## 方法二：二叉搜索树（BST） （TimeOut） ##

> 算法

用一个自平衡二叉搜索树来维护一个k大小的滑动窗口

> 思路

这是基于法一的优化，当我们在思考一道题目的时候可以采用这样的思路进行。

当我们直观的想到法一，我们意识到无法减少对每个数组元素的遍历，那么是否可以降低搜索前k个元素的时间呢？

考虑到这个滑动窗口内的元素是严格遵循先进先出的，那么队列应该是我们的第一反应。
问题在于，队列的链表实现可以支持在常熟时间内的**删除**，**插入**，然而**搜索**耗费的时间依然是线性的，所以并不能提升效率。

基于这一点，我们有了法二和法三。

法二我们需要遍历数组，并对每个元素做如下的操作：
  - 在BST内搜索该元素，找到了就返回true；
  - 在BST内插入当前元素
  - 如果当前BST大小超过了k，删除最旧的元素

> 代码

见：cdBST

> 复杂度分析

- 时间复杂度：O(n*log(min(n,k)))
- 空间复杂度：O(min(n,k))

---

## 方法三、散列表 ##

> 算法：

通过散列表来维护这个k大小的窗口。

> 思路：

我们应用刚刚的思路，对数时间复杂度**搜索**操作是不够的。

那么我们是否能找到一种常数时间内完成**搜索**、**删除**、**插入**操作的数据结构呢？

自然而然就想到了散列表

> 代码：

见：cdHash

> 复杂度分析：

- 时间复杂度: O(n)
- 空间复杂度：O(min(n,k))
